# This file is part of varnish-mib -*- c -*-
# Copyright (C) 2014 Sergey Poznyakoff
#
# Varnish-mib is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3, or (at your option)
# any later version.
#
# Varnish-mib is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with varnish-mib.  If not, see <http://www.gnu.org/licenses/>.

# This macro inserts a comment instructing Emacs and vi that
# this file is read-only.  It must be called at the end of the file.	
@define ROCOM@
/* Local variables:
   buffer-read-only: t
   End:
   vi: set ro:
*/
@enddefine@
@open ${name}@
/* THIS FILE IS GENERATED AUTOMATICALLY.  PLEASE DO NOT EDIT. */

#include <config.h>
#include <stdlib.h>
#include <stdint.h>

#include <vapi/vsc.h>
#include <vapi/vsm.h>

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

static struct VSM_data *vd;

void
varnish_snmp_init(void)
{
    vd = VSM_New();

    if (VSM_Open(vd))
        exit(1);
}

void
varnish_snmp_deinit(void)
{
    VSM_Close(vd);
}

@startperl@
$vars{'varnish_translate'} = sub {
    my $name = shift;
    my %trans = (
	clientAcceptedConnections => 'sess_conn',
	clientRequestsReceived    => 'client_req',
	clientCacheHits           => 'cache_hit',
	clientCacheHitsPass       => 'cache_hitpass',
	clientCacheMisses         => 'cache_miss',
	backendConnSuccess        => 'backend_conn',
	backendConnNotAttempted   => 'backend_unhealthy',
	backendConnToMany         => 'backend_busy ',
	backendConnFailures       => 'backend_fail',
	backendConnReuses         => 'backend_reuse',
	backendConnRecycled       => 'backend_recycle',
	backendConnUnused         => 'backend_toolate',
	totalSessions             => 's_sess ',
	totalRequests             => 's_req ',
	totalPipe                 => 's_pipe',
	totalPass                 => 's_pass',
	totalFetch                => 's_fetch',
	totalHeaderBytes          => 's_req_hdrbytes',
	totalBodyBytes            => 's_req_bodybytes'
	);

    my $r = $trans{$name};
    if (!defined($r)) {
	print STDERR "no translation for $name!\n";
	exit(1);
    }
    $vars{'varnish_member'} = $r;
    return 0;
};

$vars{'modulename'} = $vars{'name'};
$vars{'modulename'} =~ s#.*/##;
$vars{'modulename'} =~ s/\.c$//;
print "$vars{'modulename'}\n";

0;
@endperl@

/* Variable handlers.

   An instance handler only hands us one request at a time, unwrapping
   any eventual GETNEXT requests.  All OIDs are read-only, so the handlers
   should only handle GET requests.
*/

@foreach $i scalar@
static int
handle_$i(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    uint32_t val;
    
  @startperl@
    &{$vars{'varnish_translate'}}($vars{'i'});
  @endperl@
    if (reqinfo->mode == MODE_GET) {
	struct VSC_C_main const *st = VSC_Main(vd, NULL);
	if (!st)
	    return SNMP_ERR_NOSUCHNAME;
	snmp_set_var_typed_value(requests->requestvb, $i.type,
				 &st->$varnish_member,
				 sizeof(st->$varnish_member));
    } else {
      snmp_log(LOG_ERR, "unknown mode (%d) in handle_${i}\n",
	       reqinfo->mode );
      return SNMP_ERR_GENERR;
    }

  return SNMP_ERR_NOERROR;
}
@end@

/** Initializes the $name module */
void
init_$modulename(void)
{
  @foreach $i scalar@
    const oid ${i}_oid[] = { $i.commaoid };
  @end@

  DEBUGMSGTL(("$name", "Initializing\n"));

  @foreach $i scalar@
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("$i", handle_$i,
                               ${i}_oid, OID_LENGTH(${i}_oid),
    @if !$i.settable@
                               HANDLER_CAN_RONLY
    @end@
    @if $i.settable@
                               HANDLER_CAN_RWRITE
    @end@
        ));
  @end@
    varnish_snmp_init();
}

void
deinit_$modulename(void)
{
    varnish_snmp_deinit();
}
@calldefine ROCOM@
