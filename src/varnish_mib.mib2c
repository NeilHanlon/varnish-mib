# This file is part of varnish-mib -*- c -*-
# Copyright (C) 2014 Sergey Poznyakoff
#
# Varnish-mib is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3, or (at your option)
# any later version.
#
# Varnish-mib is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with varnish-mib.  If not, see <http://www.gnu.org/licenses/>.

# This macro inserts a comment instructing Emacs and vi that
# this file is read-only.  It must be called at the end of the file.	
@define ROCOM@
/* Local variables:
   buffer-read-only: t
   End:
   vi: set ro:
*/
@enddefine@
@open ${name}@
/* THIS FILE IS GENERATED AUTOMATICALLY.  PLEASE DO NOT EDIT. */

#include "varnish_mib.h"

static struct VSM_data *vd;

void
varnish_snmp_init(void)
{
    vd = VSM_New();

    if (VSM_Open(vd))
        exit(1);
}

void
varnish_snmp_deinit(void)
{
    VSM_Close(vd);
}

@startperl@
$vars{'varnish_translate'} = sub {
    my $name = shift;
    my %trans = (
        uptime                    => [ 'MAIN', 'uptime' ],
	clientAcceptedConnections => [ 'MAIN', 'sess_conn' ],
	clientRequestsReceived    => [ 'MAIN', 'client_req' ],
	clientCacheHits           => [ 'MAIN', 'cache_hit' ],
	clientCacheHitsPass       => [ 'MAIN', 'cache_hitpass' ],
	clientCacheMisses         => [ 'MAIN', 'cache_miss' ],
	clientBan                 => [ 'STRING', '',
				       { varnish_set_action => 'varnish_ban' }  ],

	clientRequestsReceived    => [ 'MAIN', 'client_req' ],
	clientRequests400         => [ 'MAIN', 'client_req_400' ],
	clientRequests411         => [ 'MAIN', 'client_req_411' ],
	clientRequests413         => [ 'MAIN', 'client_req_413' ],
	clientRequests417         => [ 'MAIN', 'client_req_417' ],

	
	backendConnSuccess        => [ 'MAIN', 'backend_conn' ],
	backendConnNotAttempted   => [ 'MAIN', 'backend_unhealthy' ],
	backendConnToMany         => [ 'MAIN', 'backend_busy' ],
	backendConnFailures       => [ 'MAIN', 'backend_fail' ],
	backendConnReuses         => [ 'MAIN', 'backend_reuse' ],
	backendConnRecycled       => [ 'MAIN', 'backend_recycle' ],
	backendConnUnused         => [ 'MAIN', 'backend_toolate' ],
	backendConnRetry          => [ 'MAIN', 'backend_retry' ],
	
	totalSessions             => [ 'MAIN', 's_sess' ],
	totalRequests             => [ 'MAIN', 's_req' ],
	totalPipe                 => [ 'MAIN', 's_pipe' ],
	totalPass                 => [ 'MAIN', 's_pass' ],
	totalFetch                => [ 'MAIN', 's_fetch' ],
	totalRequestHeaderBytes   => [ 'MAIN', 's_req_hdrbytes' ],
	totalRequestBodyBytes     => [ 'MAIN', 's_req_bodybytes' ],
	totalResponseHeaderBytes  => [ 'MAIN', 's_resp_hdrbytes' ],
	totalResponseBodyBytes    => [ 'MAIN', 's_resp_bodybytes' ],

	sessAccepted              => [ 'MAIN', 'sess_conn'],
	sessQueued                => [ 'MAIN', 'sess_queued'],
	sessDropped               => [ 'MAIN', 'sess_dropped'], 
	sessClosed                => [ 'MAIN', 'sess_closed'],
	sessPipeline              => [ 'MAIN', 'sess_pipeline'],
	sessReadAhead             => [ 'MAIN', 'sess_readahead'],
	sessHerd                  => [ 'MAIN', 'sess_herd'],
	sessDrop                  => [ 'MAIN', 'sess_drop'],
	sessFail                  => [ 'MAIN', 'sess_fail'],
 	sessPipeOverflow          => [ 'MAIN', 'sess_pipe_overflow'], 

	threadsPools              => [ 'MAIN', 'pools'],
	threadsTotal              => [ 'MAIN', 'threads'],
	threadsLimitHits          => [ 'MAIN', 'threads_limited'],
	threadsCreated            => [ 'MAIN', 'threads_created'],
	threadsDestroyed          => [ 'MAIN', 'threads_destroyed'],
	threadsFailed             => [ 'MAIN', 'threads_failed'],
	threadsQueueLength        => [ 'MAIN', 'thread_queue_len'], 

	bansTotal                 => [ 'MAIN', 'bans' ],
	bansCompleted             => [ 'MAIN', 'bans_completed' ],
	bansObj                   => [ 'MAIN', 'bans_obj' ],
	bansReq                   => [ 'MAIN', 'bans_req' ],
	bansAdded                 => [ 'MAIN', 'bans_added' ],
	bansDeleted               => [ 'MAIN', 'bans_deleted' ],
	bansTested                => [ 'MAIN', 'bans_tested' ],
	bansObjectsKilled         => [ 'MAIN', 'bans_obj_killed' ],
	bansLurkerTested          => [ 'MAIN', 'bans_lurker_tested' ],
	bansTestTested            => [ 'MAIN', 'bans_tests_tested' ],
	bansLurkerTestTested      => [ 'MAIN', 'bans_lurker_tests_tested' ],
	bansLurkerObjKilled       => [ 'MAIN', 'bans_lurker_obj_killed' ],
	bansDups                  => [ 'MAIN', 'bans_dups' ],
	bansLurkerContention      => [ 'MAIN', 'bans_lurker_contention' ],
	bansPersistedBytes        => [ 'MAIN', 'bans_persisted_bytes' ],
	bansPersistedFragmentation => [ 'MAIN', 'bans_persisted_fragmentation' ],
	
	);

    my $r = $trans{$name};
    if (!defined($r)) {
	print STDERR "no translation for $name!\n";
	exit(1);
    }

    $vars{'varnish_type'} = $r->[0];
    $vars{'varnish_member'} = $r->[1];
    if ($#{$r} == 2) {
	@vars{keys %{$r->[2]}} = values %{$r->[2]};
    } else {
	delete $vars{$setkw};
    }
    return 0;
};

$vars{'modulename'} = $vars{'name'};
$vars{'modulename'} =~ s#.*/##;
$vars{'modulename'} =~ s/\.c$//;
print "$vars{'modulename'}\n";

0;
@endperl@

/* Variable handlers.

   An instance handler only hands us one request at a time, unwrapping
   any eventual GETNEXT requests.  
*/

@foreach $i scalar@
static int
handle_$i(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
  @if $i.settable@
    int ret;
  @end@
    
  @startperl@
    &{$vars{'varnish_translate'}}($vars{'i'});
  @endperl@
      
    if (VSM_Abandoned(vd)) {
        DEBUGMSGTL(("$modulename", "reopening vd\n"));
	VSM_Close(vd);
	VSM_Open(vd);
    }
  
    switch(reqinfo->mode) {
    case MODE_GET:
  @if $varnish_type eq 'MAIN'@
    {			    
        struct VSC_C_main const *st = VSC_Main(vd, NULL);
    @if $i.type eq 'ASN_COUNTER64'@
        struct counter64 ctr;
	if (!st)
	    return SNMP_ERR_NOSUCHNAME;
	ctr.high = st->$varnish_member >> 32;
	ctr.low = st->$varnish_member & 0xffffffff;
	snmp_set_var_typed_value(requests->requestvb, $i.type,
				 &ctr,
				 sizeof(ctr));
    @else@
	if (!st)
	    return SNMP_ERR_NOSUCHNAME;
	snmp_set_var_typed_value(requests->requestvb, $i.type,
				 &st->$varnish_member,
				 sizeof(st->$varnish_member));
    @end@
    }
  @elsif $varnish_type eq 'STRING'@
    {
	const char *s = "$varnish_member";
	snmp_set_var_typed_value(requests->requestvb, $i.type,
				 s, strlen(s));
    }
  @else@
    @printf "unrecognized type %s for %s" $varnish_type $i@
  @end@
        break;

  @if $i.settable@
    /*
     * SET REQUEST
     *
     * multiple states in the transaction.  See:
     * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
     */
    case MODE_SET_RESERVE1:
	/* or you could use netsnmp_check_vb_type_and_size instead */
	ret = netsnmp_check_vb_type(requests->requestvb, $i.type);
        if (ret != SNMP_ERR_NOERROR)
	    netsnmp_set_request_error(reqinfo, requests, ret);
	break;

    case MODE_SET_RESERVE2:
    @if $varnish_set_reserve2 ne ''@
        if ($varnish_set_reserve2 (reqinfo, requests, vd)) {
	    netsnmp_set_request_error(reqinfo, requests,
				      SNMP_ERR_RESOURCEUNAVAILABLE);
	}
    @end@
	break;

    case MODE_SET_FREE:
    @if $varnish_set_free ne ''@
        # Free resources allocated in RESERVE1 and/or
	# RESERVE2.  Something failed somewhere, and the states
	# below won't be called. */
        $varnish_set_free(reqinfo, requests, vd);
    @end@
	break;

    case MODE_SET_ACTION:
    @if $varnish_set_action ne ''@
        ret = $varnish_set_action(reqinfo, requests, vd);
        if (ret != SNMP_ERR_NOERROR)
	    netsnmp_set_request_error(reqinfo, requests, ret);
    @end@
	break;

    case MODE_SET_COMMIT:
    @if $varnish_set_commit ne ''@
	# delete temporary storage
        if ($varnish_set_commit(reqinfo, requests, vd))
	    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
    @end@
	break;

    case MODE_SET_UNDO:
    @if $varnish_set_undo ne ''@
	# UNDO and return to previous value for the object
        if ($varnish_set_undo(reqinfo, requests, vd))
	    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
    @end@
	break;
  @end@

    default:
	/* we should never get here, so this is a really bad error */
	snmp_log(LOG_ERR, "unknown mode (%d) in handle_${i}\n", reqinfo->mode );
	return SNMP_ERR_GENERR;
    }
    
    return SNMP_ERR_NOERROR;
}
@end@

/** Initializes the $name module */
void
init_$modulename(void)
{
  @foreach $i scalar@
    const oid ${i}_oid[] = { $i.commaoid };
  @end@

  DEBUGMSGTL(("$modulename", "Initializing\n"));

  @foreach $i scalar@
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("$i", handle_$i,
                               ${i}_oid, OID_LENGTH(${i}_oid),
    @if !$i.settable@
                               HANDLER_CAN_RONLY
    @end@
    @if $i.settable@
                               HANDLER_CAN_RWRITE
    @end@
        ));
  @end@
    varnish_snmp_init();
}

void
deinit_$modulename(void)
{
    varnish_snmp_deinit();
}
@calldefine ROCOM@
